from typing import *

# по тому, что не дана структура ноды можно догадаться о том,
# что задача решается не деревом, а чем-то другим (арифметика и т.д.)
class Solution:
    def numTrees(self, n: int) -> int:
        '''
        как минимум у нас всегда есть n уникальных деревьев,
        т.к, все значения 1..n уникальны => руты будут уникальны.
        остается только найти кол-во уникальных для левого поддерева
        (значения слева от текущего) и кол-во уникальных для правого поддерева
        (значения справа от текущего). Если же рассмотреть как рут самый первый
        элемент, то левая часть останется пуста. Но bst от нул рута - 
        уже 1 уникальная структура. Правую часть пока что считать не будем. 
        Пойдем дальше. Берем как рут, значение 2. Слева останется
        1 значение. BST от одного рута - 1 уникальная структура. Также можно
        побрутфорсить для 2, 3 значений. Также можно заметить, что кол-во 
        уникальных структур не зависит от значений, добавляемых в BST элементов,
        кол-во уникальных структур останется тем же.
        Из этого можно сделать вывод, что задача решается динамическим программированием.
        Способом сохранения результатов подпроблем для вычисления значений больших проблем.
        '''

        G = [0 for _ in range(n+1)]
        G[0], G[1] == 1, 1  # invariant

        for i in range(1, n+1):
            for j in range(1, i+1):
                G[i] += G[j-1] * G[i-j]
        
        return G[n]